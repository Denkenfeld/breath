<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON RESPIRATION // ZEN CORE</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body, html { width: 100vw; height: 100vh; overflow: hidden; background: #050510; font-family: 'Rajdhani', sans-serif; color: white; }
        
        /* LAYERS */
        #bg-canvas { position: fixed; top: 0; left: 0; z-index: 0; opacity: 0.6; }
        #three-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; pointer-events: none; }
        
        /* HUD ELEMENTS */
        .hud-panel { background: rgba(10, 20, 40, 0.6); border: 1px solid rgba(0, 240, 255, 0.3); backdrop-filter: blur(10px); padding: 15px; border-radius: 4px; box-shadow: 0 0 20px rgba(0, 240, 255, 0.1); transform: skewX(-10deg); pointer-events: auto; }
        
        /* TOP BAR */
        #top-bar { display: flex; justify-content: space-between; align-items: flex-start; }
        .score-box { text-align: right; }
        .label { font-size: 0.8em; color: #00f0ff; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; display: block; }
        #score { font-size: 2.5em; font-weight: 700; text-shadow: 0 0 10px rgba(0, 240, 255, 0.8); line-height: 1; }
        #level-badge { font-size: 1.2em; color: #ff0055; font-weight: bold; }

        /* CENTER ACTION */
        #center-hud { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; }
        #instruction { font-size: 3em; font-weight: 300; letter-spacing: 10px; text-transform: uppercase; text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); opacity: 0.9; margin-bottom: 20px; transition: color 0.5s; }
        #timer-ring { font-size: 1.5em; font-weight: 700; opacity: 0.5; margin-top: 260px; } /* Positioned below sphere */

        /* COMBO METER */
        #combo-container { position: absolute; right: 40px; top: 50%; transform: translateY(-50%); text-align: center; }
        #combo-num { font-size: 4em; font-weight: 700; color: #ffd700; text-shadow: 0 0 20px #ffd700; }
        #combo-label { font-size: 1em; letter-spacing: 3px; }

        /* FOOTER */
        #footer-bar { display: flex; justify-content: space-between; align-items: flex-end; }
        .progress-track { width: 300px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #00f0ff, #0055ff); width: 0%; transition: width 0.3s; box-shadow: 0 0 10px #00f0ff; }
        
        /* CONTROLS */
        .btn { background: transparent; color: #00f0ff; border: 1px solid #00f0ff; padding: 10px 30px; font-family: 'Rajdhani', sans-serif; font-size: 1.2em; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s; transform: skewX(-10deg); margin-left: 10px; pointer-events: auto; }
        .btn:hover { background: #00f0ff; color: #000; box-shadow: 0 0 20px #00f0ff; }
        
        /* OVERLAYS */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 5, 16, 0.95); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s; }
        .hidden { opacity: 0; pointer-events: none; }
        h1 { font-size: 5em; margin-bottom: 10px; background: linear-gradient(to right, #00f0ff, #ff0055); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; font-weight: 700; letter-spacing: 5px; }
        .subtitle { font-size: 1.5em; color: #aaa; margin-bottom: 40px; letter-spacing: 2px; }
        
        /* FLOATING TEXT ANIMATION */
        .floater { position: absolute; font-weight: bold; font-size: 1.5em; pointer-events: none; animation: floatUp 1.5s ease-out forwards; text-shadow: 0 0 10px currentColor; }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-100px) scale(1.5); } }

        @media (max-width: 768px) { h1 { font-size: 3em; } #combo-container { display: none; } .hud-panel { padding: 10px; } }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>
    <div id="three-container"></div>

    <div id="start-screen" class="overlay">
        <h1>Neon Respiration</h1>
        <p class="subtitle">Synchronisiere deinen Geist // Level Up Your Calm</p>
        <div style="display: flex; gap: 20px; text-align: left; margin-bottom: 40px; font-size: 1.2em; color: #00f0ff;">
            <div>âš¡ 4s Einatmen<br>ðŸ”’ 4s Halten</div>
            <div>ðŸ’¨ 4s Ausatmen<br>ðŸ”’ 4s Halten</div>
        </div>
        <button id="start-btn" class="btn" style="font-size: 1.5em; padding: 20px 60px;">System Starten</button>
    </div>

    <div id="ui-layer" class="hidden">
        <div id="top-bar">
            <div class="hud-panel">
                <span class="label">Status</span>
                <div id="phase-status" style="font-size: 1.2em;">STANDBY</div>
            </div>
            <div class="hud-panel score-box">
                <span class="label">Core Sync XP</span>
                <div id="score">0</div>
                <div id="level-badge">LVL 01</div>
            </div>
        </div>

        <div id="center-hud">
            <div id="instruction">BEREIT MACHEN</div>
            <div id="timer-ring">--</div>
        </div>

        <div id="combo-container">
            <div id="combo-num">x1</div>
            <div id="combo-label">STREAK</div>
        </div>

        <div id="footer-bar">
            <div class="hud-panel">
                <span class="label">Session Progress</span>
                <div class="progress-track"><div id="progress-fill" class="progress-fill"></div></div>
                <div style="margin-top: 5px; font-size: 0.9em; display:flex; justify-content:space-between;">
                    <span id="cycle-count">0 / 10 Zyklen</span>
                    <span id="time-display">0:00</span>
                </div>
            </div>
            <div>
                <button id="sound-btn" class="btn">ðŸ”Š</button>
                <button id="stop-btn" class="btn">ABBRUCH</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script>
        // --- GAME CONFIG & STATE ---
        const CONFIG = {
            phases: [
                { name: 'EINATMEN', duration: 4, color: 0x00f0ff, scale: 2.2, text: "LADEN" },
                { name: 'HALTEN', duration: 4, color: 0xff0055, scale: 2.2, text: "FOKUS" },
                { name: 'AUSATMEN', duration: 4, color: 0x88ff00, scale: 1.0, text: "LÃ–SEN" },
                { name: 'HALTEN', duration: 4, color: 0xffaa00, scale: 1.0, text: "STILLE" }
            ],
            targetCycles: 10,
            baseScore: 100
        };

        let state = {
            running: false,
            phaseIndex: 0,
            phaseTime: 0,
            totalTime: 0,
            cycles: 0,
            score: 0,
            streak: 1,
            level: 1,
            audioEnabled: true
        };

        // --- AUDIO SYSTEM (Procedural Ambient) ---
        const AudioSys = {
            ctx: null,
            gainMaster: null,
            oscillators: [],
            
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.gainMaster = this.ctx.createGain();
                this.gainMaster.connect(this.ctx.destination);
                this.gainMaster.gain.value = 0.3;
                this.createDrone();
            },

            createDrone: function() {
                // Binaural / Drone layers
                const freqs = [110, 112, 220, 330]; // Am chords
                freqs.forEach(f => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    gain.gain.value = 0;
                    osc.connect(gain);
                    gain.connect(this.gainMaster);
                    osc.start();
                    this.oscillators.push({ osc, gain, baseFreq: f });
                });
            },

            updateDrone: function(phaseProgress, phaseIndex) {
                if (!this.ctx) return;
                const time = this.ctx.currentTime;
                
                // Modulate volume and detune based on breath phase
                // Inhale: Rising pitch/volume. Exhale: Lowering.
                const isInhale = phaseIndex === 0;
                const isHold = phaseIndex === 1 || phaseIndex === 3;
                const isExhale = phaseIndex === 2;

                this.oscillators.forEach((o, i) => {
                    let targetVol = 0.05;
                    let targetFreq = o.baseFreq;

                    if (isInhale) {
                        targetVol = 0.1 + (phaseProgress * 0.1);
                        targetFreq = o.baseFreq + (phaseProgress * 5); 
                    } else if (isExhale) {
                        targetVol = 0.2 - (phaseProgress * 0.15);
                        targetFreq = o.baseFreq + 5 - (phaseProgress * 5);
                    } else if (isHold) {
                        targetVol = 0.1;
                    }

                    o.gain.gain.setTargetAtTime(targetVol, time, 0.1);
                    o.osc.frequency.setTargetAtTime(targetFreq, time, 0.1);
                });
            },

            playNote: function(freq, type = 'sine') {
                if(!this.ctx || !state.audioEnabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.value = freq;
                osc.type = type;
                osc.connect(gain);
                gain.connect(this.gainMaster);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            },

            toggle: function() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                state.audioEnabled = !state.audioEnabled;
                this.gainMaster.gain.setTargetAtTime(state.audioEnabled ? 0.3 : 0, this.ctx.currentTime, 0.5);
                return state.audioEnabled;
            }
        };

        // --- THREE.JS VISUALS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('three-container').appendChild(renderer.domElement);
        camera.position.z = 6;

        // Core Sphere (The Player)
        const geometry = new THREE.IcosahedronGeometry(1.2, 2);
        const material = new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.5 });
        const coreSphere = new THREE.Mesh(geometry, material);
        scene.add(coreSphere);

        // Inner Light
        const innerGeo = new THREE.SphereGeometry(0.8, 32, 32);
        const innerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const innerSphere = new THREE.Mesh(innerGeo, innerMat);
        coreSphere.add(innerSphere);

        // Particle System (Starfield / Energy)
        const particlesGeo = new THREE.BufferGeometry();
        const particleCount = 400;
        const posArray = new Float32Array(particleCount * 3);
        for(let i=0; i<particleCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 15;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff, transparent: true, opacity: 0.6 });
        const particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);

        // Glow Ring (Visual Guide)
        const ringGeo = new THREE.RingGeometry(1.4, 1.45, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const guideRing = new THREE.Mesh(ringGeo, ringMat);
        scene.add(guideRing);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // --- BACKGROUND SHADER (Neural Net Vibe) ---
        const bgCanvas = document.getElementById('bg-canvas');
        const gl = bgCanvas.getContext('webgl');
        
        const vsSource = `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`;
        const fsSource = `
        precision mediump float;
        uniform float t;
        uniform vec2 r;
        void main() {
            vec2 uv = (gl_FragCoord.xy * 2. - r)/r.y;
            vec3 c = vec3(0);
            for(float i=0.; i<3.; i++){
                uv = abs(uv) - 0.4;
                float d = length(uv) * exp(-length(uv0));
                vec3 col = vec3(0.1, 0.6, 0.9);
                d = sin(d*8. + t)/8.;
                d = abs(d);
                d = pow(0.01/d, 1.2);
                c += col * d;
            }
            gl_FragColor = vec4(c, 1.0);
        }`;
        // (Simplified WebGL setup for brevity, assumes support)
        // ... Proper compile functions implied or minimal version used:
        function createShader(gl, type, src) { let s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); return s; }
        let pid = gl.createProgram();
        gl.attachShader(pid, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(pid, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(pid);
        gl.useProgram(pid);
        let attP = gl.getAttribLocation(pid, "p");
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attP);
        gl.vertexAttribPointer(attP, 2, gl.FLOAT, false, 0, 0);
        let uniT = gl.getUniformLocation(pid, "t");
        let uniR = gl.getUniformLocation(pid, "r");

        function resizeBg() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
            gl.viewport(0, 0, bgCanvas.width, bgCanvas.height);
            gl.uniform2f(uniR, bgCanvas.width, bgCanvas.height);
        }
        window.addEventListener('resize', () => {
            resizeBg();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        resizeBg();

        // --- GAME LOGIC ---

        function spawnFloatingText(text, x, y, color = "#00f0ff") {
            const el = document.createElement('div');
            el.className = 'floater';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.color = color;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1500);
        }

        function triggerLevelUp() {
            state.level++;
            state.streak += 0.5; // Multiplier boost
            document.getElementById('level-badge').textContent = "LVL " + state.level.toString().padStart(2, '0');
            AudioSys.playNote(880, 'triangle');
            spawnFloatingText("LEVEL UP!", window.innerWidth/2, window.innerHeight/2, "#ff0055");
            
            // Visual burst
            particleSystem.material.size = 0.2;
            setTimeout(() => particleSystem.material.size = 0.05, 500);
        }

        function cycleComplete() {
            state.cycles++;
            
            // XP Calculation
            const earned = Math.floor(CONFIG.baseScore * state.streak);
            state.score += earned;
            
            // Feedback
            AudioSys.playNote(440 + (state.cycles * 20), 'sine'); // Rising pitch
            spawnFloatingText(`+${earned} XP`, window.innerWidth/2 + 50, window.innerHeight/2 - 100);
            
            // Streak
            if(state.cycles % 2 === 0) {
                state.streak += 0.1;
                spawnFloatingText("SYNC STREAK!", window.innerWidth/2 - 50, window.innerHeight/2 - 120, "#ffd700");
            }
            
            // Level Logic
            if(state.cycles % 3 === 0) triggerLevelUp();

            // Win Condition
            if(state.cycles >= CONFIG.targetCycles) {
                spawnFloatingText("SESSION COMPLETE", window.innerWidth/2, window.innerHeight/2, "#00ff00");
                document.getElementById('instruction').textContent = "SYSTEM SYNCED";
                document.getElementById('instruction').style.color = "#00ff00";
            }

            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score').textContent = state.score.toLocaleString();
            document.getElementById('combo-num').textContent = "x" + state.streak.toFixed(1);
            document.getElementById('cycle-count').textContent = `${state.cycles} / ${CONFIG.targetCycles}`;
            
            const pct = (state.cycles / CONFIG.targetCycles) * 100;
            document.getElementById('progress-fill').style.width = `${Math.min(pct, 100)}%`;
        }

        // --- MAIN LOOP ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Shader Bg
            gl.uniform1f(uniT, time * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            const dt = (time - lastTime) / 1000;
            lastTime = time;

            if (state.running) {
                state.totalTime += dt;
                state.phaseTime += dt;

                const currentPhase = CONFIG.phases[state.phaseIndex];
                
                // Phase Transition
                if (state.phaseTime >= currentPhase.duration) {
                    state.phaseTime = 0;
                    state.phaseIndex = (state.phaseIndex + 1) % CONFIG.phases.length;
                    
                    // New Phase Logic
                    const nextPhase = CONFIG.phases[state.phaseIndex];
                    document.getElementById('instruction').textContent = nextPhase.text;
                    document.getElementById('phase-status').textContent = nextPhase.name;
                    document.getElementById('instruction').style.color = '#' + nextPhase.color.toString(16);
                    
                    if (state.phaseIndex === 0) {
                        cycleComplete();
                    } else {
                        // Small beep for phase change
                         AudioSys.playNote(220, 'sine');
                    }
                }

                // Update Progress Visuals
                const progress = state.phaseTime / currentPhase.duration;
                
                // Three.js Animations
                let targetScale = 1;
                let ringScale = 1;
                
                if (state.phaseIndex === 0) { // Inhale
                    targetScale = 1 + (CONFIG.phases[0].scale - 1) * progress;
                    ringScale = targetScale * 1.2;
                } else if (state.phaseIndex === 1) { // Hold (High)
                    targetScale = CONFIG.phases[1].scale;
                    ringScale = targetScale * 1.2;
                    // Pulsate slightly
                    targetScale += Math.sin(time * 0.005) * 0.05;
                } else if (state.phaseIndex === 2) { // Exhale
                    targetScale = CONFIG.phases[1].scale - (CONFIG.phases[1].scale - 1) * progress;
                    ringScale = targetScale * 1.2;
                } else { // Hold (Low)
                    targetScale = 1;
                    ringScale = 1.2;
                    targetScale += Math.sin(time * 0.005) * 0.05;
                }

                coreSphere.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                guideRing.scale.set(ringScale, ringScale, ringScale);
                
                const col = new THREE.Color(currentPhase.color);
                coreSphere.material.color.lerp(col, 0.05);
                guideRing.material.color.lerp(col, 0.05);
                particleSystem.material.color.lerp(col, 0.02);

                // Rotate visuals
                coreSphere.rotation.y += 0.005;
                coreSphere.rotation.z += 0.002;
                particleSystem.rotation.y -= 0.001;
                
                // Update HUD Timer text
                const timeLeft = Math.ceil(currentPhase.duration - state.phaseTime);
                document.getElementById('timer-ring').textContent = timeLeft;

                // Update Audio Drone
                AudioSys.updateDrone(progress, state.phaseIndex);
                
                // Time Display
                const m = Math.floor(state.totalTime / 60);
                const s = Math.floor(state.totalTime % 60).toString().padStart(2, '0');
                document.getElementById('time-display').textContent = `${m}:${s}`;
            }

            renderer.render(scene, camera);
        }

        // --- EVENTS ---
        document.getElementById('start-btn').addEventListener('click', () => {
            AudioSys.init();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            state.running = true;
            lastTime = performance.now();
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            location.reload();
        });
        
        document.getElementById('sound-btn').addEventListener('click', (e) => {
            const isOn = AudioSys.toggle();
            e.target.textContent = isOn ? 'ðŸ”Š' : 'ðŸ”‡';
        });

        animate(0);

    </script>
</body>
</html>
